# Porensics 2
Description:
```markdown
Well, we were able to get the attackers out and added some mitigations to the binary, but apparently they got in again??

*Note - I provided the libc, but if you really want it, I ran it on the `legoclones/pwn:ubuntu-24.04` Docker container*

[porensics2.zip]
```

## Writeup
This time, NX was enabled and the binary was dynamically-compiled. The attacker used ret2plt to obtain a libc leak from the Global Offset Table. Then, he performed a ret2mprotect attack to change the last segment of memory for the executable to be RWX, added shellcode to that segment, and jumped there. Note that the binary was patched to include a `pop $rsi; ret` gadget and make the read be 0x300 bytes in length.

The first-stage shellcode (which is unencrypted) multiplies the `$rcx` register by 0x1337 and uses that as the XOR key to decrypt the second-stage shellcode (which **IS** encrypted). The `$rcx` register is at a constant offset from the base address of the libc segment, and looking at the binary in GDB should reveal that. They can then use that XOR key to decrypt the second-stage shellcode which looks similar to Porensics 1; it gets the flag and XORs it with a pre-determined but randomly-generated 8-byte XOR key. XORing the traffic with that key will reveal the flag.

The working exploit and shellcode can be found in `exploit.py`.

**Flag** - `HC{encrypt3d_sh3llc0d3_g03s_h4rd!}`