# Pwn 201
Description:
```markdown
This challenge requires you to exploit a use-after-free vulnerability. Note that this challenge uses GLIBC 2.27, meaning a lot of modern heap protections aren't present - make sure you're developing the exploit using the libc version in the Dockerfile!

Can you forge your own fake chunk to read the flag?

`nc pwn201.youcanhack.me 1337`

[pwn201.zip]
```

## Writeup
The flag is located in `chunk0`. When you allocate and free two more chunks (`chunk1` and `chunk2`), `chunk2` points to `chunk1` using the `fd_ptr` metadata field. Using the read option, you can print out that pointer. Then, you calculate the offset to `chunk0` and replace the `fd_ptr` with that address. When you allocate another chunk, `chunk2` will be reallocated (becoming `chunk3`), pushing `chunk0` to the top of the tcache list. Then, allocating another chunk will cause `chunk0` to become `chunk4`, and reading it will print out the flag.

Note that the flag is placed 0x10 bytes from the start of `chunk0` data because bytes 8-15 get zero'ed during this process. Those bytes are zero'ed because when chunk1 is reallocated, the fd_ptr of chunk2 (which was changed to actually be chunk0) is set to NULL since there's no other chunks in the tcache. This process is automated in `solve.py`.

**Flag** - `HC{moving_from_stack_pwn_to_UAF_c4n_b3_qu1t3_th3_jump_huh}`

## Hosting
`pwn201` was compiled with the command `gcc -o pwn201 -fstack-protector-all pwn201.c`.

This challenge should be a Docker container that runs `pwn201` on port 1337. All the proper files are included in here. The command to build the docker container is (when located inside of this directory):

```bash
docker compose up -d
```

To stop the challenge:
```bash
docker compose down
```